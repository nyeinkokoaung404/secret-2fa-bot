// functions/2fa_handlers.js
///////////////////////////////////////////////
// Copyright (C) t.me/nkka404
// Channel: https://t.me/premium_channel_404
///////////////////////////////////////////////

import {
    get_text,
    sendMessage,
    editMessageText,
    isCommandMessage,
} from './utils.js';

import {
    get_user_language,
    isUserBanned,
} from './db.js';

import { 
    TELEGRAM_BOT_TOKEN_ENV,
    BAN_REPLY,
} from './config.js';

// --- Constants ---
const PARSE_MODE = 'Markdown';
const SECRET_REGEX = /^[A-Z2-7\s]+$/i;

// --- Keep existing base32Decode and generateTOTP functions ---

/**
 * Decodes a Base32 string (RFC 4648) to a raw binary ArrayBuffer key.
 * This mimics PHP's base32Decode logic closely.
 * @param {string} secret - Base32 secret string.
 * @returns {ArrayBuffer | null} Raw binary key or null if invalid.
 */
function base32Decode(secret) {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    secret = secret.toUpperCase().replace(/\s/g, '').replace(/[^A-Z2-7]/g, '');

    if (!secret) return null;

    let bits = "";
    for (const c of secret) {
        const v = alphabet.indexOf(c);
        if (v === -1) continue;
        bits += v.toString(2).padStart(5, "0");
    }

    const bytes = [];
    for (let i = 0; i < bits.length; i += 8) {
        const byte = bits.substring(i, i + 8);
        if (byte.length === 8) {
            bytes.push(parseInt(byte, 2));
        }
    }

    return new Uint8Array(bytes).buffer;
}

/**
 * Generates TOTP code using HMAC-SHA1 and Dynamic Truncation.
 * @param {string} secret - Base32 secret string.
 * @returns {Promise<string | null>} 6-digit TOTP code or null on error.
 */
async function generateTOTP(secret) {
    const keyBuffer = base32Decode(secret);
    if (!keyBuffer) return null;
    
    const epochSeconds = Math.floor(Date.now() / 1000);
    const timeStep = Math.floor(epochSeconds / 30);
    
    const msgBuffer = new ArrayBuffer(8);
    const dataView = new DataView(msgBuffer);
    
    dataView.setUint32(0, 0, false); 
    dataView.setUint32(4, timeStep, false); 

    const cryptoKey = await crypto.subtle.importKey(
        'raw', 
        keyBuffer, 
        { name: 'HMAC', hash: 'SHA-1' }, 
        false, 
        ['sign']
    );
    
    const hashBuffer = await crypto.subtle.sign('HMAC', cryptoKey, msgBuffer);
    const hashView = new Uint8Array(hashBuffer);

    const offset = hashView[hashView.length - 1] & 0x0F;

    const truncatedHashView = new DataView(hashBuffer, offset, 4);
    let binary = truncatedHashView.getUint32(0, false); 
    binary = binary & 0x7FFFFFFF;

    const code = binary % 1000000;
    return String(code).padStart(6, "0");
}

// --- New: Direct Secret Message Handler ---

/**
 * Handles direct secret messages (not commands)
 */
export async function handleSecretMessage(chatId, userId, message, env) {
    const token = env[TELEGRAM_BOT_TOKEN_ENV];
    const lang = await get_user_language(chatId, env);
    
    // 1. Ban Check
    if (await isUserBanned(userId, env)) {
        await sendMessage(chatId, BAN_REPLY, null, true, token, PARSE_MODE);
        return;
    }

    const rawText = message.text?.trim();
    
    // Skip if it's a command or empty message
    if (!rawText || isCommandMessage(message)) {
        return;
    }

    // Clean and validate the secret
    const clean_secret = rawText.toUpperCase().replace(/\s/g, '').replace(/[^A-Z2-7]/g, '');
    
    // Check if it looks like a valid Base32 secret
    if (clean_secret.length < 16 || !SECRET_REGEX.test(rawText)) {
        // Not a valid secret, ignore the message
        return;
    }

    const loading_message = await sendMessage(chatId, "*ðŸ” Generating TOTP code...*", null, true, token, PARSE_MODE);
    const loading_message_id = loading_message?.data?.result?.message_id;

    try {
        const totp_code = await generateTOTP(clean_secret);

        if (!totp_code) {
            throw new Error("TOTP generation failed internally.");
        }

        const epochSeconds = Math.floor(Date.now() / 1000);
        const seconds_passed = epochSeconds % 30;
        const seconds_remaining = 30 - seconds_passed;
        
        // User info
        const from_user = message.from;
        const user_name = `${from_user.first_name || ''} ${from_user.last_name || ''}`.trim() || from_user.username || `User ${from_user.id}`;
        const user_link = `[${user_name}](tg://user?id=${from_user.id})`;

        // Successful Response
        const response_text = 
            `**ðŸ” TOTP Code Generated âœ…**\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `*Code:* \`${totp_code}\`\n` +
            `*Expires in:* \`${seconds_remaining}\` seconds\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `*Secret:* \`${clean_secret.substring(0, 8)}...${clean_secret.slice(-4)}\`\n\n` +
            `*Generated By:* ${user_link}\n` +
            `*Via:* Direct Secret Message`;

        await editMessageText(chatId, loading_message_id, response_text, null, true, token, PARSE_MODE);

    } catch (e) {
        console.error(`Direct Secret Handler Error: ${e.message}`);
        const error_message = get_text('2fa_error', lang) || `*âŒ Error generating code: ${e.message.substring(0, 50)}*`;
        await editMessageText(chatId, loading_message_id, error_message, null, true, token, PARSE_MODE);
    }
}

// --- Updated Main Handler Logic ---

/**
 * Creates the user information string for the final message caption.
 * @param {Object} message - The message object.
 * @returns {string} Markdown formatted user link.
 */
function create_user_link(message) {
    const from_user = message.from;
    
    if (from_user) {
        const name = `${from_user.first_name || ''} ${from_user.last_name || ''}`.trim() || from_user.username || `User ${from_user.id}`;
        // Markdown user link format: [name](tg://user?id=id)
        return `[${name}](tg://user?id=${from_user.id})`;
    } else {
        const group = message.chat.title || "this group";
        const url = message.chat.username ? `https://t.me/${message.chat.username}` : "";
        return url ? `[${group}](${url})` : group;
    }
}

/**
 * Handles the /2fa command for TOTP code generation.
 */
export async function handle2FACommand(chatId, userId, message, commandBase, paramString, env) {
    const token = env[TELEGRAM_BOT_TOKEN_ENV];
    const lang = await get_user_language(chatId, env);
    
    // 1. Ban Check
    if (await isUserBanned(userId, env)) {
        await sendMessage(chatId, BAN_REPLY, null, true, token, PARSE_MODE);
        return;
    }

    const raw_secret = paramString?.trim();

    if (!raw_secret) {
        const error_message = get_text('2fa_secret_missing', lang) || "*âŒ Secret not provided. Please include the Base32 secret.*";
        await sendMessage(chatId, error_message, null, true, token, PARSE_MODE);
        return;
    }
    
    const clean_secret = raw_secret.toUpperCase().replace(/\s/g, '').replace(/[^A-Z2-7]/g, '');

    if (!clean_secret) {
        const error_message = get_text('2fa_invalid_secret', lang) || "*âŒ Invalid Secret. Please provide a valid Base32 secret string.*";
        await sendMessage(chatId, error_message, null, true, token, PARSE_MODE);
        return;
    }

    const loading_message = await sendMessage(chatId, "*Generating TOTP code...*", null, true, token, PARSE_MODE);
    const loading_message_id = loading_message?.data?.result?.message_id;

    try {
        const totp_code = await generateTOTP(clean_secret);

        if (!totp_code) {
             throw new Error("TOTP generation failed internally.");
        }

        const epochSeconds = Math.floor(Date.now() / 1000);
        const seconds_passed = epochSeconds % 30;
        const seconds_remaining = 30 - seconds_passed;
        
        // User link
        const user_link = create_user_link(message);

        // Successful Response
        const response_text = 
            `**ðŸ” TOTP Code Generated âœ…**\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `*Code:* \`${totp_code}\`\n` +
            `*Expires in:* \`${seconds_remaining}\` seconds\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `*Secret:* \`${clean_secret.substring(0, 8)}...${clean_secret.slice(-4)}\`\n\n` +
            `*Generated By:* ${user_link}`;

        await editMessageText(chatId, loading_message_id, response_text, null, true, token, PARSE_MODE);

    } catch (e) {
        console.error(`TOTP Handler Error: ${e.message}`);
        const error_message = get_text('2fa_error', lang) || `*âŒ Error generating code: ${e.message.substring(0, 50)}*`;
        await editMessageText(chatId, loading_message_id, error_message, null, true, token, PARSE_MODE);
    }
}
